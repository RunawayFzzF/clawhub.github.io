### 软件工程学习参考

#### 名词解释

1.  软件工程（P4）

2.  基线（P58）

3.  软件需求（P71）

4.  用例（93）

5.  软件设计（135Or136？）

6.  软件构造（282）

7.  耦合和内聚


####  问答

1.  需求的分类（P76，6种）

2.  需求分析的任务（82）

3.  界面设计原则（人机交互设计原则）

4. 区分设计与实现的界限（283）

5. 软件构造的主要活动


####  第一、二章 软件工程基础

#####  1.1名词解释

 1.1.1 软件工程（4）

1）应用系统的、规范的、可量化的方法来开发、运行和维护软件，即将工程应用到软件。

 2）对 1）中各种方法的研究。 

#####  1.2 简答

1.2.1 从1950s~2000s之间的特点

![](/img/in-post/2018-04-27-software-engineering-directory/软件工程的特点1.png)

![](/img/in-post/2018-04-27-software-engineering-directory/软件工程的特点2.png)

#### 第四章 项目启动

##### 4.1 名词解释

4.1.1 质量属性（54）

4.1.2 质量模型（54）

4.1.3 配置管理（58）

4.1.4 配置项（58）

4.1.5 基线（58）

##### 4.2 软件项目管理活动有哪些？（过程组、具体活动）（49,13年选择）

##### 4.3 如何管理团队？

4.3.1在实验中采取了哪些办法？有哪些经验？

 团队结构：1）主程序员团队 2）民主团队 3）开放团队 
 团队建设：1）建立团队章程 2）持续成功 3）和谐沟通 4）避免团队杀手

4.3..2团队结构有三种★（50）

1）主程序员团队 2）民主团队 3）开放团队 

##### 4.4 质量模型有哪些（h，55）

##### 4.5 质量保障有哪些措施？★

4.5.1结合实验进行说明★

##### 4.6 配置管理有哪些活动？★

4.6.1实验中是如何进行配置管理的？★

##### 4.7 质量验证的方法有三种（56）

##### 4.8 项目的质量保障包括哪些活动？（56）

4.8.1例：（2010）结合实验，说明一个项目的质量保障包括哪些活动？

##### 4.9  典型的评审过程有六个阶段（56）

##### 4.10  变更控制过程是怎样的（61）

（第一、二、四章中考一个简答题）

#### 第五章 软件需求基础

##### 5.1 名词解释

5.1..1 需求（71）

1）用户为了解决问题或达到某些目标所需要的条件或能力

 2）系统或系统部件为了满足合同、标准、规范或其他正式文档所规定的要求
而需要具备的条件或能力 

3）对 1） 或 2）中的一个条件或一种能力的一种文档化表述 

##### 5.2 需求获取的三种方法（69）

##### 5.3 区分需求的三个层次（71）

*5.3.1 **给出**一**个实例，给出其三个层次的例**⼦***

5.3 .2对给定的需求示例，判定其层次

5.3 2.1 例如课程实验/ATM/图书管理…

##### *5.4 **掌握需求的类型***

5.4.1对给定的实例，给出其不同类型的需求例⼦

5.4.2对给定的需求⽰例，判定其类型

5.4.2.1 例如课程实验/ATM/图书管理…

#### 第六章 需求分析方法

##### 6.1 为给定的描述

6.1.1 建立用例图

6.1.2 建立分析类图

6.1.3 建立系统顺序图

6.1.4 建立状态图

6.1.5 为下列描述建立用例模型（6分），要求明确给出建模过程（4分）。

![](/img/in-post/2018-04-27-software-engineering-directory/需求分析方法1.png)

![](/img/in-post/2018-04-27-software-engineering-directory/需求分析方法2.png)

##### 6.2 简：需求分析的方法

##### 6.3 简：需求分析模型（84，6种）

##### 6.4 简：结构化分析方法（85，2种）

##### 6.5 简：面向对象方法（4种）

##### 6.6 数据流图怎么画

##### 6.7 实体关系图怎么画

##### 6.8 用例描述怎么写

##### 6.9 概念类图怎么画

##### 6.10 顺序图怎么画

##### 6.11 状态图怎么画

#### 第七章 需求文档化与验证

##### 7.1 为什么需要需求规格说明？结合实验进行说明

##### 7.2 对给定的需求用例，判定并修正其错误

7.2 .1 对给定的需求规格说明片段，找出并修正其错误

##### 7.3 对给定的需求示例，设计功能测试用例

7.3 .1结合测试方法

#### 第八章 软件设计基础

##### 8.1 名词解释

8.1.1软件设计

是关于软件对象的设计，是一种设计活动，具有设计的普遍特性。

##### 8.2 软件设计的核心思想是什么？

分解和抽象。 
分解是横向上将系统分割为几个相对简单的子系统以及各子系统之间的关系。 
分解之后每次只需关注经过抽象的相对简单的子系统以及相互之间的关系，从而降低了复杂度。 
抽象则是在纵向上聚焦各子系统的接口（与实现相对）。接口是各子系统之间交流的契约，是整个系统的关键所在。 

##### 8.3 软件工程设计有哪三个层次？各层的主要思想是什么？软件设计的核心思想是什么（139）

高层、中层、低层设计。 
 高层设计：基于反映软件高层抽象的构建层次，描述系统的高层结构、关注点和设计决策。 
 中层设计：关注组成构件的模块的划分、导入和导出、过程之间调用关系或者类的协作。 
 低层设计：深入模块和类的内部，关注具体的数据结构、算法、类型、语句和控制结构等。

##### 8.4 软件设计设计过程的四个主要活动（140）

##### 8.5 软件设计的方法（140）

##### 8.6 常见的设计视角

#### 第九、十章 软件体系结构

##### 9.1 体系结构的概念

一个软件系统的体系结构规定了系统的计算部件和部件之间的交互。

##### 9.2  体系结构的风格的优缺点★

 主程序/子程序： 
 优点：流程清晰，易于理解。强控制性。 
 缺点：程序调用是一种强耦合的连接方式，难以修改和复用。程序调用的连接方式限制了各部件的数据交互。 
 面向对象式： 
 优点：内部实现的可修改性。易开发、易理解、易服用的结构组织。 
 缺点：无法消除接口的耦合。标识耦合。副作用。 
 分层： 


 优点：设计机制清晰易于理解。支持并行开发。更好的可复用性和内部可修改性。 
 缺点：交互协议难以修改。性能损失。难以确定层次数量和粒度。 
 MVC： 
 优点：易开发性。视图的控制和可修改性。适宜于网络系统开发的特征。 
 缺点：复杂性。模型修改困难。

##### 9.3 体系结构设计的过程？

 1）分析关键需求和项目约束； 
 2）选择体系结构风格； 
 3）进行软件体系结构逻辑（抽象）设计； 
 4）依赖逻辑设计进行软件体系结构实现物理（实现）设计； 
 5）完善软件体系结构设计； 
 6）定义构件接口； 
 7）迭代过程 3）~ 6）。 

##### 9.4 包的原则

逻辑设计中的每一个包对应一个开发包。（开发包、依赖的其他包） 

##### 9.5  体系结构构建之间接口的定义（*）

提供的服务（供接口）：语法、前置条件、后置条件 
 需要的服务（需接口）：服务名、服务 

##### 9.6  体系结构开发集成测试用例

9.6 .1 Stub和Driver

（桩Stub、驱动Driver） 
 桩：自顶向下集成，下层的模块使用伪装的具有相同接口的桩。 
 驱动：自底向上集成，从底层的模块集成起，测试的时候上层的模块使用伪装的相同接口的驱动。 
 集成测试用例：模拟实现。 

##### 9.7 （体系结构评审？） 

#### 第十一章 人机交互评审

##### 11.1 名词解释

11.1.1可用性

 易用性包括易学性、易记性、效率、出错率和主观满意度。 
 易学性是指新手用户容易学习，能够很快使用系统。 
 易记性是指以前使用过软件系统的用户能有效记忆或者快速地重新学会使用该系统。 
 效率是指熟练用户使用系统完成任务的速度。 


 出错率是指用户在使用系统时，会犯多少错，错误有多严重，以及是否能从错误中很容易地恢复。 
 主观满意度是让用户有良好的体验。 

##### 11.2能够列出至少5个界面设计的注意事项，并加以解释

 简洁设计：不要使用太大的菜单，不要在一个窗口中表现过多的信息类别，不要在一个表单中使用太多的颜色和字体作为线索。 
 一致性设计：依据精神模型。不要让按钮位置不一致。 
 低出错率设计：提供简洁的指导帮助用户消除错误。 
 易记性设计：减少用户的记忆负担。 

11.2.1例子**违反了哪些条界面设计原则

##### 11.3 人机交互设计的人类因素：（精神模型、差异性）

精神模型：指用户进行人机交互时头脑中的人物模型，人机交互设计需要依据精神模型来进行隐喻设计。 
 差异性：不同用户群体的任务模型是有差异的。分为新手用户、专家用户和熟练用户，分别关注易学性、效率、和两者折中。 

##### 11.4  人机交互设计的交互性：（导航、反馈、协作式设计）

导航：提供完成任务的入口。 
 反馈：视觉、声音上的反馈，让用户能意识到行为的结果，提示用户交互行为的后果。 
 协作式设计：人和计算机是人机交互的两方，其中人的因素是比较固定的，一定时期内不会发生大的变化，所以要让二者交互顺畅，就
需要让计算机更多地适应人的因素，这也是人机交互设计以用户为中心的根本原因。这种调整计算机因素以更好地适应并帮助用户的设计方式被称为协
作式设计。 

 ![](/img/in-post/2018-04-27-software-engineering-directory/人机交互评审1.png)

![](/img/in-post/2018-04-27-software-engineering-directory/人机交互评审2.png)

 

#### 第十二章 详细设计基础

##### 12.1 详细设计的出发点

软件详细设计应该在软件体系结构设计之后进行，以需求开发的结果和软件体系结构的结果为出发点。 

##### 12.2 职责分配[★]()

##### 12.3 协作

##### 12.4 控制风格（208）★

职责分配、协作和控制风格：1）通过职责建立静态模型 2）通过协作建立动态模型 
 职责： 1）抽象对象的职责（属性职责和方法职责） 
 2）抽象类之间的关系（依赖、关联、聚合、组合、继承）（类图 P204） 
 3）添加辅助类 
 协作： 1）抽象对象之间的协作（顺序图、状态图 P207） 
 2）明确对象的创建 
 3）选择合适的控制风格：集中式、委托式、分散式（P209-210） 

##### 12.5给定分析类图、系统顺序图和设计因素描述

12.5.1 建立设计类图★

12.5.2 或者详细顺序图★

##### 12.6 协作的测试

12.6 .1 MockObject

类间协作的桩程序通常被称为Mock Object，不同于stub。Mock的测试代码更简单。（P211） 

 ![](/img/in-post/2018-04-27-software-engineering-directory/详细设计基础.png)

#### 第十三章 模块化与信息隐藏

##### 13.1 名词解释

13.1 .1 解释耦合与内聚[★]()

 耦合：描述了两个模块之间的复杂程度。 
 内聚：表达了一个模块内部联系的紧密型。 

##### 13.2 耦合与内聚的判断★

（根据例子说明他们之间的耦合程度/内聚，并给出理由） 
 耦合：（高→低）内容耦合、公共耦合、重复耦合、控制耦合、印记耦合、数据耦合。（P219）耦合越高越不利于软件变更。 
 内聚：（高→低）信息内聚、功能内聚、通信内聚、过程内聚、时间内聚、逻辑内聚、偶然内聚。（P220）内聚越低越不易实现变更。 

13.2.1 对例子**，说明它们之间的耦合程度与内聚，给出理由★

##### 13.3 六种耦合解释及例子

##### 13.4 七种内聚解释及其例子

##### 13.5 信息隐藏★

13.5.1 基本思想★

每个模块隐藏一个重要的设计决策，抽象出类的关键细节（职责）。即抽象出接口，隐藏实现。 

13.5.2 两种常见的信息隐藏决策

职责的实现、实现的变更。 

13.5.3 对例子**，说明其信息隐藏程度好坏★

#####  13.6（模块说明？主要秘密、次要秘密、角色、对外接口） 

  ![](/img/in-post/2018-04-27-software-engineering-directory/模块化与信息隐藏.png)

#### 第十四章 面向对象下的模块化

##### 14.1   Principles fromModularization  模块化原则

14.1 .1 《GlobalVariables Consider Harmful》    全局变量考虑有害

14.1 .2 《To be Explicit》                                     要明确

14.1 .3 《Do not Repeat》                                     不要重复

（降低访问耦合的方法）

14.1 .4  Programming to Interface (Design by Contract)        面向接口编程（抽象设计）

14.1 .5  The Law of Demeter                                 迪米特法则

14.1 .6  Interface Segregation Principle(ISP)         接口分离原则

 （降低继承耦合的方法） 

14.1 .7  Liskov Substitution Principle (LSP)         Liskov替换原则（里氏代换原则）

14.1 .8  Favor Composition Over Inheritance       使用组合代替继承

 （提高内聚的方法） 

14.1 .9 集中信息与行为的原则

14.1 .10  Single Responsibility Principle             单一职责原则

##### 14.2  • 对给定的示例，发现其所违反的原则，并进行修正

#####  14.3（度量？） 

#### 第十五章 面向对象下的信息隐藏

##### 15.1 信息隐藏的含义

1）封装类的职责，隐藏职责的实现 2）预计将会发生的变更，抽象它的接口，隐藏它的内部机制 

##### 15.2 封装

1）将数据和行为同时包含在类中 2）分离对外接口和内部实现 

##### 15.3 多态

##### 15.4 OCP 开闭原则

 Open Close Principle 开闭原则 
 好的设计应该对“扩展”开放，好的设计应该对“修改”关闭。即发生变更时，好的设计只需要添加新的代码就能实现变更。 

##### 15.5 DIP 依赖倒置原则

Dependency Inversion Principle 依赖倒置原则 
抽象不应该依赖于细节，高层模块不依赖于低层模块，都应依赖于抽象。 

  ![](/img/in-post/2018-04-27-software-engineering-directory/面向对象下的信息隐藏.png)

#### 第十六章 详细设计的设计模式

##### 16.1  如何实现可修改性、可扩展性、灵活性

 包括狭义的可修改性、可扩展性和灵活性。 
 方法： 需要能够将接口和实现分离。 
 Java等面向对象语言中的实现方式： 
 1）通过接口和实现该接口的类完成接口和实现的分离。 
 2）通过子类继承父类将父类的接口，将父类的接口和子类的实现相分离。 

##### 16.2   策略模式

 抽象Strategy，实现不同的ConcreteStrategy方法，Context拥有Strategy的一个引用。 

##### 16.3  抽象工厂模式

 AbstractFactory声明接口，ConcreteFactory实现对产品的创建。 
 AbstractProduct定义产品接口，ConcreteProduct实现具体工厂创建出来的产品，实现接口。 
 Client使用AbstractFactory和AbstractProduct来创建。 

##### 16.4   单件模式

 Singleton提供访问单件的接口，负责实现单件。 
 Client通过getInstance使用单件。 

##### 16.5   迭代器模式

 Iterator定义访问和遍历的接口，ConcreteIterator实现接口。 
 Aggregate定义创建相应迭代器对象的接口，ConcreteAggregate实现接口。 

##### *16.6 **给定场景，应**⽤**设计模式并写出代码***

##### *16.7  **给出代码，要求**⽤**设计模式改写***

#### 第十七、十八章 软件构造与代码设计

##### 17.1   构造包含的活动

##### 17.2  名词解释

17.2.1 重构

修改软件系统的严谨方法，它在不改变代码的外部表现的情况下改进其内部结构。 

17.2.2 测试驱动开发

编写代码之前优先完成该段代码的测试代码。 

17.2.3 结对编程

两个程序员挨着坐在一起共同协作进行软件构造活动。分为Driver（驾驶员）负责输入代码和Observer（观察员）进行评审。 

##### **17.3**   给定代码段示例，对其进行改进或者 发现其中的问题

17.3.1 简洁性/可维护性

17.3.2 使用数据结构消减复杂判定

17.3.3 控制结构

17.3.4 变量使用

17.3.5 语句处理

17.3.6 How to write unmaintainable code

17.3.7 防御与错误处理

##### 17.4 单元测试用例的设计（P313） 

 根据方法规格或者方法的逻辑结构开发单元测试用例。

##### 17.5  契约式设计代码设计 包括了异常和断言。（P309） 

 异常：代码开始执行判断前置条件，结束执行后判断后置条件，不符合抛出异常（throw）。 
 断言：代码开始执行检查前置条件，结束执行后检查后置条件，不符合抛出异常（assert）。 
 Java中在Public方法中使用异常，Protected、Private方法中是用断言。

##### **17.6**  防御式编程代码设计（P310） 

保护方法内部不受损害。会增加复杂度降低易读性和性能，但是增加了可靠性。 

##### 17.7  表驱动 （P307）

 通过计算出决策表（P311）来判断是否发生事件（Level Array）。 

#### 第十九章 软件测试

##### 19.1   掌握白盒测试和黑盒测试的常用方法，并进行能够优缺点比较

##### 19.2  能解释并区别白盒测试三种不同的方法：语句覆盖、分支覆盖和路径覆盖

##### 19.3  给出一个场景，判断应该使用哪种测试方法，如何去写（*）

19.3.1 对给定的场景和要求的测试方法，设计测试用例

19.3.1.1  给出功能需求，则要求写功能测试用例

19.3.1.2  给出设计图，则要求写集成测试用例，Stub and Driver

19.3.1.3  给出方法的描述，则要求写单元测试用例，Mock Object

19.3.1.4  JUnit基本使用方法

#### 第二十、二十一章

##### 20.1   如何理解软件维护的重要性？

##### 20.2   开发可维护软件的方法

##### **20.3**   演化式生命周期模型

##### **20.4**   用户文档、系统文档

##### 20.5  逆向工程、再工程

#### 第二十二、二十三章 软件开发过程模型以及职业基础

##### 22.1  软件生命周期模型

需求工程→软件设计→软件实现→软件测试→软件交付→软件维护。 

##### 22.2  Build-and-fix model 构建-修复模型

缺点：没有考虑最基本的生命周期。没有分析需求的真实性。没有考虑软件结构的质量。没有考虑可维护性。 


 适用范围：软件规模很小、质量要求不高、对后期维护要求不高的程序可以使用。 

##### 22.3  Waterfall model 瀑布模型

按照一个阶段到另一个阶段的有序的转换序列。要求每一个活动必须进行验证。 
 需求工程→软件设计→软件实现→软件测试→软件交付→软件维护（可以迭代反复）。 
 缺点：对文档的高期望、对开发活动的线性预设、客户用户参与不够、里程碑粒度过粗。 
 适用范围：需求非常成熟稳定、技术可靠、复杂度适中的工程。 

##### 22.4  Iterative Models 迭代模型

22.4 .1  Incremental model 增量迭代模型

22.4 .1.1   Incremental Delivery 渐进交付

优点：有更好的适用性，并行开发可以帮助缩短软件产品的开发时间，渐进交付可以加强用户反馈降低开发风险。 
 缺点：加入构件不能破坏已经构造的部分，需要玩呗清晰的项目前景。 
 适用范围：相对稳定、成熟的领域。 

22.4 2  Evolutionary 演化

22.4 .2.1  Evolutionary development 演化模型

多个迭代、并行的瀑布式开发活动。 
 优点：迭代式开发适用于需求变更比较快的系统开发，并行开发降低了软件产品的开发时间，渐进交付加强用户反馈。 
 缺点：无法确定项目范围不好把握，后续迭代容易蜕变为Build-Fix模式。 
 适用范围：不稳定领域的大规模系统开发。 

22.4 .2.2  Prototyping 原型模型

注重使用抛弃式原型（不确定部分）而不是演化式原型（成为产品的一部分的原型）。 
 需求开发部分迭代（抛弃式原型）：原型需求→设计原型→构件原型→评估原型。 
 优点：加强了客户用户的交流，适用于新颖的领域。 
 缺点：原型方法在避免风险时候带来新的风险，质量较差的代码导致低质量。 
 适用范围：不确定性较多的软件开发。 

22.4 .2.3  Spiral Model 螺旋模型

为了尽早解决比较高的风险。是迭代与瀑布的结合（开发阶段：瀑布式 风险分析：迭代式） 
 优点：可以降低风险，减少项目因风险造成的损失。 
 缺点：自身带来风险，模型过于复杂。 
 适用范围：高风险的大规模软件系统开发。 

##### 22.5 解释与比较不同过程模型（要求、特征描述、优点、缺点）

##### 22.6  对给定的场景，判定适用的开发过程模型

##### 22.7  软件工程程知识体系的知识域



#### 其他

##### 21.1        什么是可用性设计

产品在特定使用环境下为特定用户用于特定用途时所具有的有效性（effectiveness）、效率（efficiency）和用户主观满意度（satisfaction）。其中：

有效性 -用户完成特定任务和达到特定目标时所具有的正确和完整程度；

效率 -用户完成任务的正确和完整程度与所使用资源（如时间）之间的比率；

满意度 -用户在使用产品过程中所感受到的主观满意和接受程度。 

可用性设计就是在以用户为中心的宗旨下，进行产品（系统）的设计，以使产品满足功能需要、符合用户的行为习惯和认知，同时能高效愉悦的完成任务和工作，达到预期的目的。

============================

 